# MeDrive AI Development Guide

## 1. Project Overview

MeDrive is a self-hostable cloud file hosting application, similar to Google Drive. It's a full-stack monorepo project with a Next.js frontend, a Nest.js backend, and a separate Next.js app for documentation.

**Core Features:**
- User Authentication (Login/Signup)
- Main application with a sidebar and main content area.
- Dashboard with stats and recent files.
- "My Drive" page for file and folder management.
- Nested folders.
- File uploads and folder creation.
- A 10-section marketing landing page.

## 2. Tech Stack

**Frontend (Web App):**
- Framework: Next.js (App Router)
- UI: Tailwind CSS, shadcn/ui
- State Management: Zustand, TanStack Query
- Forms: React Hook Form
- Authentication: NextAuth.js
- Testing: Vitest, Playwright

**Backend (Server):**
- Framework: Nest.js
- Database: Supabase (PostgreSQL)
- ORM: Prisma
- File Storage: Cloudinary
- Authentication: JWT (implemented in Nest.js)
- Testing: Jest

**Tooling:**
- Monorepo: Turborepo
- CI/CD: GitHub Actions, Vercel (for web/docs), Render (for server)

## 3. Project Structure

This project is a monorepo managed by Turborepo. The `apps` directory contains the individual applications (`web`, `server`, `docs`), and the `packages` directory contains shared code.

### Root Monorepo Structure

```
./
├── apps/                    # Contains all independent applications
│   ├── web/                 # Next.js frontend application
│   ├── server/              # Nest.js backend application
│   └── docs/                # Next.js documentation site
├── packages/                # Contains shared packages/libraries
│   ├── ui/                  # Reusable UI components (e.g., shadcn/ui extensions)
│   ├── config/              # Shared configurations (ESLint, TypeScript, etc.)
│   ├── db/                  # Database client and schema (Prisma)
│   └── types/               # Shared TypeScript types and interfaces
├── .github/                 # GitHub Actions workflows
│   └── workflows/
│       ├── ci.yml           # Continuous Integration workflow
│       └── release.yml      # Semantic Release workflow
├── node_modules/            # Project dependencies (hoisted by Yarn)
├── .env.example             # Template for root environment variables
├── .eslintrc.js             # Root ESLint configuration
├── .gitignore               # Git ignore rules
├── next.config.js           # Root Next.js configuration (if applicable)
├── package.json             # Root package.json with workspace definitions and scripts
├── pnpm-lock.yaml           # pnpm lock file (if using pnpm)
├── README.md                # Project README
├── turbo.json               # Turborepo configuration
├── tsconfig.json            # Root TypeScript configuration
└── yarn.lock                # Yarn lock file
```

### Web App (Next.js)

```
apps/web/
├── .next/                    # Next.js build output (auto-generated)
├── public/                   # Static assets served directly
│   ├── favicon.ico          # Application favicon
│   ├── robots.txt          # SEO robots configuration
│   ├── sitemap.xml         # SEO sitemap
│   └── images/             # Static images (logos, icons, etc.)
│       ├── logo.svg
│       └── placeholders/
├── src/
│   ├── app/                 # App Router (Next.js 13+)
│   │   ├── (auth)/          # Authentication routes group
│   │   │   ├── login/       # Login page
│   │   │   │   └── page.tsx
│   │   │   ├── signup/      # Signup page
│   │   │   │   └── page.tsx
│   │   │   ���── layout.tsx   # Auth layout wrapper
│   │   ├── (main)/          # Main application routes group
│   │   │   ├── dashboard/   # Dashboard page
│   │   │   │   └── page.tsx
│   │   │   ├── drive/       # My Drive page
│   │   │   │   ├── [folderId]/  # Dynamic folder route
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx     # Root drive page
│   │   │   ├── layout.tsx   # Main layout with sidebar
│   │   │   └── loading.tsx  # Main area loading state
│   │   ├── api/             # API routes (if needed)
│   │   ├── globals.css      # Global styles
│   │   ├── layout.tsx       # Root layout
│   │   └── page.tsx         # Marketing landing page
│   ├── components/          # React components
│   │   ├── ui/              # shadcn/ui components
│   │   ├── layout/          # Layout components
│   │   ├── features/        # Feature-specific components
│   │   └── providers/       # Context providers
│   ├── lib/                 # Utility functions
│   ├── hooks/               # Custom React hooks
│   ├── stores/              # Zustand stores
│   ├── types/               # TypeScript type definitions
│   ├── config/              # Configuration files
│   └── styles/              # Additional styles
├── tests/                   # Test files
├── .env.local              # Local environment variables
├── .env.example            # Environment variables template
├── next.config.js          # Next.js configuration
├── tailwind.config.ts      # Tailwind CSS configuration
├── tsconfig.json           # TypeScript configuration
├── package.json            # Dependencies and scripts
└── README.md               # Web app documentation
```

### Server App (Nest.js)

```
apps/server/
├── dist/                    # Compiled JavaScript output
├── src/
│   ├── main.ts             # Application entry point
│   ├── app.module.ts       # Root application module
│   ├── config/             # Configuration module
│   ├── common/             # Shared/common code
│   ├── modules/            # Feature modules
│   ├── database/            # Database configuration
│   ├── middleware/          # Custom middleware
│   └── health/              # Health check endpoints
├── test/                    # E2E tests
├── prisma/                  # Prisma ORM
├── uploads/                 # Local file storage (development)
├── logs/                    # Application logs
├── .env                     # Environment variables
├── .env.example             # Environment template
├── .env.test               # Test environment variables
├── nest-cli.json           # Nest CLI configuration
├── tsconfig.json           # TypeScript configuration
├── tsconfig.build.json     # Build-specific TypeScript config
├── jest.config.js          # Jest testing configuration
├── package.json            # Dependencies and scripts
└── README.md               # Server documentation
```

## 4. Data Flows

### 4.1. User Authentication Flow

1.  **User Signup (Web):** User fills out the signup form on the Next.js app.
2.  **API Request (Web -> Server):** The web app sends a `POST /auth/register` request to the Nest.js server with email, password, and name.
3.  **User Creation (Server):** The server hashes the password, creates a new user in the Supabase database via Prisma, and generates a JWT access token and a refresh token.
4.  **Response (Server -> Web):** The server sends the user object, access token, and refresh token back to the web app.
5.  **Session Management (Web):** The web app stores the tokens (e.g., in cookies or local storage) and manages the user's session using NextAuth.js.

### 4.2. File Upload Flow

1.  **User Action (Web):** User clicks the "Upload" button and selects a file in the Next.js app.
2.  **API Request (Web -> Server):** The web app sends a `POST /files/upload` request (as `multipart/form-data`) to the Nest.js server, including the file and optional `folderId`.
3.  **File Storage (Server -> Cloudinary):** The Nest.js server receives the file and uploads it to Cloudinary.
4.  **Database Entry (Server):** Upon successful upload to Cloudinary, the server creates a new file record in the Supabase database via Prisma, storing metadata like the file name, size, type, and the Cloudinary URL.
5.  **Response (Server -> Web):** The server sends the new file object back to the web app.
6.  **UI Update (Web):** The web app updates the UI to show the newly uploaded file.

## 5. Do's and Don'ts

### Do's:

-   **Follow the Project Structure:** Adhere strictly to the folder structures defined in `project-structure-web.md` and `project-structure-server.md`.
-   **Use the Tech Stack:** Only use the technologies specified in the `spec-sheet.md`.
-   **Write Tests:** Follow a Test-Driven Development (TDD) approach. Write tests for all new features.
-   **Use Conventional Commits:** Follow the conventional commit format for all git commits.
-   **Keep Components Small and Reusable:** Break down UI into small, reusable components.
-   **Use DTOs:** Use Data Transfer Objects (DTOs) for all API requests and responses.
-   **Use Environment Variables:** Never hardcode secrets or configuration values. Use the `.env` files.
-   **Use Strict Typing:** Adhere to strict ESLint rules. Always use proper types and interfaces.

### Don'ts:

-   **Don't Introduce New Dependencies:** Do not add new libraries or packages without approval.
-   **Don't Mix Business Logic in Controllers:** Keep business logic in services (`*.service.ts`). Controllers should only handle HTTP requests and responses.
-   **Don't Write Large Components:** Avoid creating monolithic components. Keep them focused on a single responsibility.
-   **Don't Bypass the ORM:** Always use Prisma for database interactions. Do not write raw SQL queries.
-   **Don't Ignore Errors:** Implement proper error handling and logging.
-   **Don't Use `any`:** Avoid using the `any` type. Always define a proper type or interface.

## 6. Development Workflow

### Branching Strategy

-   **`main`**: This is the production branch. It is protected, and code is only merged into it from the `dev` branch via pull requests.
-   **`dev`**: This is the development branch. All feature branches are created from `dev`.
-   **Feature Branches**: When working on a new feature or bugfix, always create a new branch from `dev`. The branch name should be descriptive (e.g., `feat/user-authentication`, `fix/login-bug`).

### Commits and Merging

-   **Atomic Commits**: Make small, atomic commits that represent a single logical change.
-   **Conventional Commits**: All commit messages must follow the Conventional Commits specification (e.g., `feat: ...`, `fix: ...`, `chore: ...`).
-   **Test-Driven Development (TDD)**: All development must follow TDD principles. Write tests before writing the implementation code.
-   **Merging**: Once a feature is complete and all tests pass, merge the feature branch back into `dev`. Then, push the `dev` branch to the remote repository.

## 7. CI/CD

The project uses GitHub Actions for Continuous Integration and Continuous Delivery.

-   **CI (Continuous Integration)**: The CI workflow runs on every push to the `main` and `dev` branches. It runs linters, tests, and builds the applications.
-   **Release**: The release workflow is triggered when the `dev` branch is merged into `main`. It uses `semantic-release` to automatically version, create a changelog, and publish the new release.

## 8. Project Tooling & Commands

-   **Package Manager**: The project uses `yarn` version `1.22.22`.
-   **Adding Packages**: To add a new package to a specific app in the monorepo, run the following command from the root of the project:
    ```bash
    yarn workspace [app-name] add [package-name]
    ```
    Replace `[app-name]` with the name of the app (e.g., `web`, `server`) and `[package-name]` with the name of the package.

## 9. UI Development Documentation

The UI development documentation is located in the `docs/ui-docs/` directory. It provides a comprehensive guide to all the UI components used in the project.

The main entry point for the UI documentation is `docs/ui-docs/ui.md`. This file contains a list of all available components and links to their detailed documentation. Each component has its own markdown file with installation and usage instructions.

When adding a new component, please ensure you create a new markdown file for it and link it in `ui.md`.

## 10. Code Examples

### Example: Creating a New Component (Web)

When creating a new feature component, place it in `src/components/features/<feature-name>/`. For example, a new `UserProfile` component would be at `src/components/features/users/UserProfile.tsx`.

Components should be pure functional arrow functions with direct props destructuring. Do not use `React.FC`.

```tsx:src/components/features/users/UserProfile.tsx
import React from 'react';

interface UserProfileProps {
  name: string;
  email: string;
}

export const UserProfile = ({ name, email }: UserProfileProps) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
    </div>
  );
};
```

### Example: Creating a New API Endpoint (Server)

When creating a new endpoint, add it to the appropriate module. For example, a new endpoint to get a user's friends would be in the `users` module.

```typescript:src/modules/users/users.controller.ts
// ... imports

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  // ... other methods

  @Get(':id/friends')
  @UseGuards(JwtAuthGuard)
  async getFriends(@Param('id') id: string) {
    return this.usersService.getFriends(id);
  }
}
```

```typescript:src/modules/users/users.service.ts
// ... imports

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  // ... other methods

  async getFriends(userId: string) {
    // Business logic to get friends from the database
    return this.prisma.user.findUnique({ where: { id: userId } }).friends();
  }
}
```